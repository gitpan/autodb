.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.14
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Class::AutoDB::Serialize 3"
.TH Class::AutoDB::Serialize 3 "2006-04-06" "perl v5.8.5" "User Contributed Perl Documentation"
.SH "NAME"
Class::AutoDB::Serialize \- Serialization engine for Class::AutoDB \-\-
MySQL only for now
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This is a mixin class that enables objects to be serialized and stored
in a database as independent entities, and later fetched one-by-one or
in groups. Whether fetched individually or in groups, the original
shared object structure is preserved. It's not necessary for the object
to also from Class::AutoClass, although the examples here all do.
.Sh "Define class that inherits from Class::AutoDB::Serialize"
.IX Subsection "Define class that inherits from Class::AutoDB::Serialize"
Person class with attributes 'name', 'sex', 'hobbies', and 'friends',
where 'friends' is a list of Persons.
.PP
.Vb 4
\& package Person;
\& use Class::AutoClass;
\& use Class::AutoDB::Serialize;
\& @ISA=qw(Class::AutoClass Class::AutoDB::Serialize);
.Ve
.PP
.Vb 5
\& @AUTO_ATTRIBUTES=qw(name sex hobbies friends);
\& @OTHER_ATTRIBUTES=qw();
\& %SYNONYMS=();
\& Class::AutoClass::declare(__PACKAGE__);
\& 1;
.Ve
.Sh "Create and store some objects"
.IX Subsection "Create and store some objects"
.Vb 5
\& use DBI;
\& use Class::AutoDB::Serialize;
\& use Person;
\& my $dbh=DBI->connect('dbi:mysql:database=ngoodman;host=localhost');
\& Class::AutoDB::Serialize->dbh($dbh);
.Ve
.PP
.Vb 10
\& my $joe=new Person(-name=>'Joe',-sex=>'male',
\&                    -hobbies=>['mountain climbing', 'sailing']);
\& my $mary=new Person(-name=>'Mary',-sex=>'female',
\&                     -hobbies=>['hang gliding']);
\& my $bill=new Person(-name=>'Bill',-sex=>'male',
\&                     -hobbies=>['cooking', 'eating', 'sleeping']);
\& # Set up friends lists
\& $joe->friends([$mary,$bill]);
\& $mary->friends([$joe,$bill]);
\& $bill->friends([$joe,$mary]);
.Ve
.PP
.Vb 4
\& # Store the objects
\& $joe->store;
\& $mary->store;
\& $bill->store;
.Ve
.PP
.Vb 4
\& # Print their object id's so you can fetch them later
\& for my $obj ($joe, $mary, $bill) {
\&   print 'name=', $obj->name, ' oid=', $obj->oid, "\en";
\& }
.Ve
.Sh "Fetch the objects"
.IX Subsection "Fetch the objects"
Assume that the oid's are passed as command line arguments
.PP
.Vb 32
\& my @oids=@ARGV;
\& my $joe=Class::AutoDB::Serialize::fetch($ARGV[0]);
\& my $mary=Class::AutoDB::Serialize::fetch($ARGV[1]);
\& my $bill=Class::AutoDB::Serialize::fetch($ARGV[2]);
\& # Print the objects' attributes
\& for my $obj ($joe, $mary, $bill) {
\&   print 'oid=', $obj->oid, "\en";
\&   print 'name=', $obj->name, "\en";
\&   print 'sex=', $obj->sex, "\en";
\&   print 'hobbies=', join(', ',@{$obj->hobbies}), "\en";
\&   print 'friends=',"\en";
\& for my $friend (@{$obj->friends}) {
\&   print ' oid=', $friend->oid, ', ';
\&   print 'name=', $friend->name, "\en";
\& }
\& print "----------\en";
\& }
\& # Change an attribute in each object to demonstrate 
\& # that shared structure is preserved
\& for my $obj ($joe, $mary, $bill) {
\&   $obj->name($obj->name.' Changed');
\& }
\& for my $obj ($joe, $mary, $bill) {
\&   print 'oid=', $obj->oid, "\en";
\&   print 'changed name=', $obj->name, "\en";
\&   print 'friends=',"\en";
\&   for my $friend (@{$obj->friends}) {
\&     print ' oid=', $friend->oid, ', ';
\&     print 'changed name=', $friend->name, "\en";
\&   }
\&   print "----------\en";
\& }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a mixin class that implements the serialization and data
storage engine for Class::AutoDB. Objects that inherit from this class
can be serialized and stored in a database as independent entities.
This only works for objects implemented as HASHes in the usual Perl
way.
.PP
What distinguishes Class::AutoDB::Serialize from the many other
excellent Perl serialization packages (eg, Data::Dumper, Storable,
\&\s-1YAML\s0) is that we serialize objects as independent entities existing
within a large network, rather than serializing entire networks as a
whole. When an object is being serialized, other
E<ldquo>auto-serializableE<rdquo> objects that are encountered are not
serialized then and there; instead a placeholder object called an Oid
(short for \fIobject identifier\fR) is emitted into the serialization
stream. When the object is later fetched, the placeholders are not
immediately fetched; instead each placeholder is fetched transparently
when the program invokes a method on it (this is accomplished via an
\&\s-1AUTOLOAD\s0 mechanism).
.PP
The purpose of all this is to make it easy for Perl programs to operate
on large databases of objects. Objects can be created, stored, and
later fetched. If the object points to other objects, they will be
fetched when needed. New objects can be created, connected to the
network of existing objects, and stored.
.SH "BUGS and WISH-LIST"
.IX Header "BUGS and WISH-LIST"
see  <http://search.cpan.org/~ccavnor/Class\-AutoDB\-0.091/docs/Serialize.html#bugs_and_wishlist>
.SH "METHODS and FUNCTIONS \- Initialization"
.IX Header "METHODS and FUNCTIONS - Initialization"
see  <http://search.cpan.org/~ccavnor/Class\-AutoDB\-0.091/docs/Serialize.html#methods_and_functions>
