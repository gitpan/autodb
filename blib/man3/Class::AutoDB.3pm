.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.14
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Class::AutoDB 3"
.TH Class::AutoDB 3 "2006-04-06" "perl v5.8.5" "User Contributed Perl Documentation"
.SH "NAME"
Class::AutoDB \- Almost automatic object persistence \-\- MySQL only for
now
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This class works closely with Class::AutoClass to provide almost
transparent object persistence.
.PP
\fIDefine class that that uses AutoDB\fR
.IX Subsection "Define class that that uses AutoDB"
.PP
Person class with attributes 'name', 'sex', 'hobbies', and 'friends',
where 'friends' is a list of Persons.
.PP
.Vb 3
\& package Person;
\& use Class::AutoClass;
\& @ISA=qw(Class::AutoClass);
.Ve
.PP
.Vb 5
\& @AUTO_ATTRIBUTES=qw(name sex friends);
\& %AUTODB=
\&   (-collection=>'Person',
\&    -keys=>qq(name string, sex string, friends list(object)));
\& Class::AutoClass::declare(__PACKAGE__);
.Ve
.PP
\fIStore new objects\fR
.IX Subsection "Store new objects"
.PP
.Vb 11
\& use Class::AutoDB;
\& use Person;
\& my $autodb=new Class::AutoDB(-database=>'test');
\& my $joe=new Person(-name=>'Joe',-sex=>'male');
\& my $mary=new Person(-name=>'Mary',-sex=>'female');
\& my $bill=new Person(-name=>'Bill',-sex=>'male');
\& # Set up friends lists
\& $joe->friends([$mary,$bill]);
\& $mary->friends([$joe,$bill]);
\& $bill->friends([$joe,$mary]);
\& $autodb->put_objects;           # store objects in database
.Ve
.PP
\fIRetrieve existing objects\fR
.IX Subsection "Retrieve existing objects"
.PP
.Vb 3
\& use Class::AutoDB;
\& use Person;
\& my $autodb=new Class::AutoDB(-database=>'test');
.Ve
.PP
.Vb 10
\& my $cursor=$autodb->find(-collection=>'Person',-name=>'Joe'); # run query
\& print "Number of Joe's in database: ",$cursor->count,"\en";
\& while (my $joe=$cursor->get_next) {                # loop getting objects
\&   # $joe is a Person object -- do what you want with it
\&   my $friends=$joe->friends;
\&   for my $friend (@$friends) {
\&     my $friend_name=$friend->name;
\&     print "Joe's friend is named $friend_name\en";
\&   }
\& }
.Ve
.PP
\&\-\- \s-1OR\s0 \*(-- 
.PP
\fIGet data in one step rather than via loop\fR
.IX Subsection "Get data in one step rather than via loop"
.PP
.Vb 5
\& use Class::AutoDB;
\& use Person;
\& my $autodb=new Class::AutoDB(-database=>'test');
\& my $cursor=$autodb->find(-collection=>'Person',-name=>'Joe');
\& my @joes=$cursor->get;
.Ve
.PP
\&\-\- \s-1OR\s0 \*(-- 
.PP
\fIRun query and get data in one step\fR
.IX Subsection "Run query and get data in one step"
.PP
.Vb 4
\& use Class::AutoDB;
\& use Person;
\& my $autodb=new Class::AutoDB(-database=>'test');
\& my @joes=$autodb->get(-collection=>'Person',-name=>'Joe');
.Ve
.PP
.Vb 12
\&        ---------------------------------
\&        Not yet implemented:
\&        Delete existing objects
\&        ---------------------------------       
\&         use Class::AutoDB;
\&         use Person;
\&         my $autodb=new Class::AutoDB(-database=>'test');
\&         my $cursor=$autodb->find(-collection=>'Person',-name=>'Joe');
\&         while (my $joe=$cursor->get_next) { 
\&           $autodb->del($joe);
\&         }
\&        ---------------------------------
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class implements a simple object persistence mechanism. It is
designed to work with Class::AutoClass.
.Sh "Persistence model"
.IX Subsection "Persistence model"
This is how you're supposed to imagine the system works. The section on
Current Design explains how it really works at present.
.PP
Objects are stored in \fIcollections\fR. Each collection has any number of
search keys, which you can think of as attributes of an object or
columns of a relational table. You can search for objects in the
collection by specifying values of search keys. For example
.PP
my
\&\f(CW$cursor\fR=$autodb\->find(\-collection=>'Person',\-name=>'Joe');
.PP
finds all objects in the 'Person' collection whose 'name' key is 'Joe'.
If you specify multiple search keys, the values are ANDed.
.PP
.Vb 8
\&        ---------------------------------
\&        Not yet implemented:
\&        ---------------------------------       
\&        The 'find' method also allows almost raw SQL
\&        queries with the caveat that these are very closely tied to the
\&        implementation and will not be portable if we ever change the
\&        implementation.
\&        ---------------------------------
.Ve
.PP
A collection can contain objects from many different classes. (This is
Perl after all \*(-- what else would you expect ??!!)
.PP
.Vb 8
\&        ---------------------------------
\&        Not yet implemented:
\&        ---------------------------------       
\&        To limit a search to objects of a specific class,
\&        you can pass a 'class' parameter to find. In fact, you can search for
\&        objects of a given class independent of the collection by specifying a
\&        'class' parameter without a 'collection'.
\&        ---------------------------------
.Ve
.PP
.Vb 10
\&        ---------------------------------
\&        Not yet implemented:
\&        ---------------------------------       
\&        When you create an object, the system
\&        automatically stores it in the database at an 'appropriate' time,
\&        presently just before Perl destroys the in-memory copy of the object.
\&        You can also store objects sooner. When you update an object, it gets
\&        marked as such, and is likewise automatically updated in the database.
\&        Again, you can do the update manually if you prefer.
\&        ---------------------------------
.Ve
.PP
You can store specific objects in the database using the 'put' method
on an object or store all objects using the 'put_objects' method on
AutoDB.
.PP
.Vb 6
\&        ---------------------------------
\&        Not yet implemented:
\&        ---------------------------------       
\&        put_objects' consults the put_policy to
\&        decide which objects to store.
\&        ---------------------------------
.Ve
.PP
.Vb 2
\& $object->put;            # store one object
\& $autodb->put_objects;    # store all objects
.Ve
.Sh "Set up classes to use AutoDB"
.IX Subsection "Set up classes to use AutoDB"
To use the mechanism, you define the \f(CW%AUTODB\fR variable in your AutoClass
definition. See Class::AutoClass. If you do not set \f(CW%AUTODB\fR, or set it
to undef or (), auto-persistence is turned off for your class.
.PP
.Vb 4
\&        ---------------------------------
\&        Not yet implemented
\&        ---------------------------------       
\&        In the simplest case, you can simply set
.Ve
.PP
.Vb 1
\&        %AUTODB=(1);
.Ve
.PP
.Vb 3
\&        This will cause your class to be persistent, using the default
\&        collection name and without any search keys.
\&        ---------------------------------
.Ve
.PP
More typically, you set \f(CW%AUTODB\fR to a \s-1HASH\s0 of the form
.PP
.Vb 3
\&  %AUTODB=(
\&    -collection=>'Person', 
\&    -keys=>qq(name string, sex string, friends list(object)));
.Ve
.PP
\&\-collection is the name of the collection that will be used to store
objects of your class (collection names must be <= 255 characters),
and
.PP
\&\-keys is a string that defines the search keys that will be defined for
the class.
.PP
The 'keys' string consists of attribute, data type pairs. Each
attribute is generally an attribute defined in the AutoClass
\&\f(CW@AUTO_ATTRIBUTES\fR or \f(CW@OTHER_ATTRIBUTES\fR variables. Technically, it's the
name of a method that can be called with no arguments. The value of an
attribute must be a scalar, an object reference, or an \s-1ARRAY\s0 (or list)
of such values.
.PP
The data type can be 'string', 'integer', 'float', 'object', 
[not yet implemented: any legal MySQL column type], or the phrase list(<data
type>), eg, 'list(integer)'. These are translated into MySQL types
as follows:
.PP
.Vb 9
\& ----------------------------------
\& | AutoDB type    | MySQL type    |
\& ----------------------------------
\& |  string        |  longtext     |
\& |  integer       |  int          |
\& |  float         |  double       |
\& |  object        |  bigint       |
\& |                | (unsigned)    |
\& ----------------------------------
.Ve
.PP
The 'keys' parameter can also be an array of attribute names, eg,
.PP
\&\-keys=>[qw(name sex)]
.PP
in which case the data type of each attribute is assumed to be
\&'string'. This works in many cases even if the data is really numeric.
.PP
The types 'object' and 'list(object)' only work on objects whose
persistence is managed by our Persistence mechanisms.
.PP
The 'collection' value may also be an array of collection names (and
may be called 'collections') in which case the object is stored in all
the collections.
.PP
A subclass need not define \f(CW%AUTODB\fR, but may instead rely on the value
set by its super\-classes. If the subclass does define \f(CW%AUTODB\fR, its
values are 'added' to those of its super\-classes. Thus, if the suclass
uses a different collection than its super\-class, the object is stored
in both. It is an error for a subclass to define the type of a search
key differently than its super\-classes. It is also an error for a
subclass to inherit a search key from multiple super-classes with
different types We hope this situation is rare!
.PP
Technically, \f(CW%AUTODB\fR is a parameter list for the register method of
Class::AutoDB. See that method for more details. Some commonly used
paramters are
.PP
.Vb 6
\&        ---------------------------------
\&        Not yet implemented
\&        ---------------------------------       
\&        -transients: an array of attributes that should not be stored. This is
\&        useful for objects that contain computed values or other information of
\&        a transient nature.
.Ve
.PP
.Vb 6
\&        -auto_gets: an array of attributes that should be automatically
\&        retrieved when this object is retrieved. These should be attributes
\&        that refer to other auto-persistent objects. This useful in cases where
\&        there are attributes that are used so often that it makes sense to
\&        retrieve them as soon as possible.
\&        ---------------------------------
.Ve
.Sh "Using AutoDB in your code"
.IX Subsection "Using AutoDB in your code"
After setting up your classes to use AutoDB, here's how you use the
mechanism.
.PP
The first step is to connect your program to the database. This is
accomplished via the 'new' method.
.PP
Then you typically retrieve some number of \*(L"top level\*(R" objects
explcitly by running a query. This is accomplished via the 'find' and
\&'get' methods (there are several flavors of 'get'). Then, you operate
on objects as usual. If you touch an object that has not yet been
retrieved from the database, the system will automatically get it for
you.
.PP
.Vb 6
\&        ---------------------------------
\&        Not yet implemented
\&        ---------------------------------       
\&        You can also manually retrieve objects at
\&        any time by running 'get'.
\&        ---------------------------------
.Ve
.PP
.Vb 12
\&        ---------------------------------
\&        Not yet implemented
\&        ---------------------------------       
\&        You can create new objects as usual and they will
\&        be automatically written to the database when you're done with them.
\&        More precisely, Class::AutoDB::Object::DESTROY writes the object to the
\&        database when Perl determines that the in-memory representation of the
\&        object is no longer needed. This is guaranteed to happen when the
\&        program terminates if not before. You can also manually write objects
\&        to the database earlier if you so desire by running the 'put' method on
\&        them. If you override DESTROY, make sure you call
\&        Class::AutoDB::Object::DESTROY in your method.
.Ve
.PP
.Vb 3
\&        You can modify objects as usual and the system will take care of
\&        writing the updates to the database, just as it does for new objects.
\&        ---------------------------------
.Ve
.PP
You can store specific objects in the database using the 'put' method
on an object or store all objects using the 'put_objects' method on
AutoDB. 
.PP
.Vb 6
\&        ---------------------------------
\&        Not yet implemented
\&        ---------------------------------       
\&        'put_objects' consults the put_policy to
\&        decide which objects to store.
\&        ---------------------------------
.Ve
.PP
.Vb 2
\& $object->put;            # store one object
\& $autodb->put_objects;    # store all objects
.Ve
.Sh "Flavors of 'new', 'find', and 'get'"
.IX Subsection "Flavors of 'new', 'find', and 'get'"
The examples in the \s-1SYNOPSIS\s0 use variables named \f(CW$autodb\fR, \f(CW$cursor\fR,
\&\f(CW$joe\fR, and \f(CW@joes\fR among others. These names reflect the various stages of
data access that arise.
.PP
The first step is to connect to the database. This is accomplished by
\&'new'.
.PP
Next a query is sent to the database and executed. This is typically
accomplished by invoking 'find' on an AutoDB object. The resulting
object (called \f(CW$cursor\fR in the \s-1SYNOPSIS\s0) is called a 'cursor' object. A
cursor object's main purpose is to enable data access. (\s-1DBI\s0
afficionados will recogonize that it's possible to 'prepare' a query
before executing it. This is done under the covers here.)
.PP
Finally data is retrieved. This is typically accomplished by invoking
\&'get_next' or 'get' on a cursor object. Data can be retrieved one
object at a time (via 'get_next') or all at once (via 'get'). As a
convenience, you can do the 'find' and 'get' in one step, by invoking
\&'get' on an AutoDB object.
.PP
The query executed by 'find' can either be a simple key based search,
or [not yet implemented: an almost raw, arbitrarily complex \s-1SQL\s0 query].
The former is specified by providing key=>value pairs as was done
in the \s-1SYNOPSIS\s0, eg,
.PP
$cursor=$autodb\->find(\-collection=>'Person',\-name=>'Joe',\-sex=>'male');
.PP
The key=>value pairs are ANDed as one would expect. The above query
retrieves all Persons whose name is Joe and sex is male.
.PP
.Vb 8
\&        ---------------------------------
\&        Not yet implemented
\&        ---------------------------------       
\&        'find' can also be invoked on a cursor object.
\&        The effect is to AND the new query with the old. This only works with
\&        queries expressed as key=E<gt>value pairs, and not raw SQL, since
\&        conjoining raw SQL is a bear.
\&        ---------------------------------
.Ve
.PP
.Vb 5
\&        ---------------------------------
\&        Not yet implemented
\&        ---------------------------------       
\&        The raw form is specifed by providing a SQL query
\&        (as a string) that lacks the SELECT phrase, eg,
.Ve
.PP
.Vb 2
\&        $cursor=$autodb-E<gt>find(qq(FROM Person WHERE name="Joe" AND
\&        sex="male"));
.Ve
.PP
.Vb 4
\&        To use this form, you have to understand the relational database schema
\&        generated by AutoDB. This is not portable across implementations, It's
\&        main value is to write complex queries that cannot be represented in
\&        the key=E<gt>value form. For example
.Ve
.PP
.Vb 5
\&         $cursor=$autodb->find(qq(FROM Person p, Person friend, Person_friends friends
\&                                 WHERE p.name="Joe" AND 
\&                                 (friend.name="Mary" OR friend.name="Bill") AND
\&                                 friends.person=p));
\&        ---------------------------------
.Ve
.Sh "Creating and initializing the database"
.IX Subsection "Creating and initializing the database"
Before you can use AutoDB, you have to create a MySQL database that
will hold your data. We do not provide a means to do this here, since
you may want to put your AutoDB data in a database that holds other
data as well. The database can be empty or not. AutoDB creates all the
tables it needs \*(-- you need not (and should not create) these yourself.
.PP
\&\fBImportant note\fR: Hereafter, the term 'database' refers to the tables
created by AutoDB. Phrases like 'create the database' or 'initialize
the database' refer to these tables only, and not the entire MySQL
database that contains the AutoDB database.
.PP
Methods are provided to create or drop the entire database (meaning, of
course, the AutoDB database, not the MySQL database) or individual
collections.
.PP
AutoDB maintains a registry that describes the collections stored in
the database. Registration of collections is usually handled by
AutoClass behind the scenes as class definitions are encountered. The
system consults the registry when running queries, when writing objects
to the database, and when modifying the database schema.
.PP
When 'new' connects to the database, it reads the registry saved from
the last time AutoDB ran. It merges this with an in-memory registry
that generally reflects the currently loaded classes. 'new' merges the
registries, and stores the result for next time if the new registry is
different from the old.
.Sh "Current Design"
.IX Subsection "Current Design"
Caveat: The present implementation assumes MySQL. It is unclear how
deeply this assumption affects the design.
.PP
Every object is stored as a \s-1BLOB\s0 constructed by Data::Dumper. The
database contains a single 'object table' for the entire database whose
schema is
.PP
.Vb 5
\& create table _AutoDB (
\&     oid bigint unsigned not null,
\&     primary key (oid),
\&     object longblob
\&     );
.Ve
.PP
The oid is a unique object identifier assigned by the system. An oid is
a permanent, immutable identifier for the object.
.PP
.Vb 6
\&        ---------------------------------
\&        Not yet implemented
\&        ---------------------------------       
\&        The name of this table can be chosen when the
\&        database is created. '_AutoDB' is the default.
\&        ---------------------------------
.Ve
.PP
For each collection, there is one table we call the base table that
holds scalar search keys, and one table per list-valued search keys.
The name of the base table is the same as the name of the collection;
there is no way to change this at present. For our Person example, the
base table would be
.PP
.Vb 6
\& create table Person (
\&     oid bigint unsigned not null,     --- foreign key pointing to _AutoDB
\&     primary key (oid),                --- also primary key here
\&     name longtext,
\&     sex longtext
\&     );
.Ve
.PP
If a Person has a significant_other (also a Person), the table would
look like this:
.PP
.Vb 7
\& create table Person (
\&     oid bigint unsigned not null,     --- foreign key pointing to _AutoDB
\&     primary key (oid),                --- also primary key here
\&     name longtext,
\&     sex longtext
\&     significant_other bigint unsigned --- foreign key pointing to _AutoDB
\&     );
.Ve
.PP
The data types specified in the 'keys' parameter are used to define the
data types of these columns. They are also used to ensure correct
quoting of values bound into \s-1SQL\s0 queries. It is safe to use 'string' as
the data type even if the data is numeric unless you intend to run
\&'raw' \s-1SQL\s0 queries against the database and want to do numeric
comparisons.
.PP
For each list valued search key, eg, 'friends' in our example, we need
another table which (no surprise) is a classic link table. The name is
constructed by concatenating the collection name and key name, with a
\&'_' in between.
.PP
.Vb 5
\& create table Person_friends (
\&     oid bigint unsigned not null,  --- foreign key pointing to _AutoDB
\&     friends bigint unsigned        --- foreign key pointing to _AutoDB
\&                                    --- (will be a Person)
\&     );
.Ve
.PP
A small detail: since the whole purpose of these tables is to enable
querying, indexes are created for each column by default (indexes can
be turned off by specifiying index=>0 to the AutoDB constructor).
.PP
When the system stores an object, it converts any object references
contained therein into the oids for those objects. In other words,
objects in the database refer to each other using oids rather than the
in-memory object references used by Perl. There is no loss of
information since an oid is a permanent, immutable identifier for the
object.
.PP
When an object is retrieved from the database, the system does \s-1NOT\s0
immediately process the oids it contains. Instead, the system waits
until the program tries to access the referenced object at which point
it automatically retrieves the object from the database. Options are
provided to retrieve oids earlier.
.PP
If a program retrieves the same oid multiple times, the system short
circuits the database access and ensures that only one copy of the
object exists in memory at any point in time. If this weren't the case,
a program could end up with two objects representing Joe, and an update
to one would not be visible in the other. If both copies were later
stored, one update would be lost. The core of the solution is to
maintain an in-memory hash of all fetched objects (keyed by oid). The
software consults this hash when asked to retrieve an object; if the
object is already in memory, it is returned without even going to the
database.
.SH "BUGS and WISH-LIST"
.IX Header "BUGS and WISH-LIST"
see  <http://search.cpan.org/~ccavnor/Class\-AutoDB\-0.091/docs/AutoDB.html#bugs_and_wishlist> 
.SH "METHODS and FUNCTIONS"
.IX Header "METHODS and FUNCTIONS"
see  <http://search.cpan.org/~ccavnor/Class\-AutoDB\-0.091/docs/AutoDB.html#methods_and_functions> 
